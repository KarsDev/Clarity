class AES {
    var keySchedule

    constructor(key) {
        keySchedule = expandKey(key)
    }

    fn encrypt(plaintext) {
        var state = toState(plaintext)
        addRoundKey(state, keySchedule, 0)
        const var rounds = keySchedule.size() / 4 - 1
        for var round = 1, round < rounds, round = round + 1 {
            subBytes(state)
            shiftRows(state)
            mixColumns(state)
            addRoundKey(state, keySchedule, round)
        }
        subBytes(state)
        shiftRows(state)
        addRoundKey(state, keySchedule, rounds)
        return toBytes(state)
    }

    fn decrypt(ciphertext) {
        var state = toState(ciphertext)
        const var rounds = keySchedule.size() / 4 - 1
        addRoundKey(state, keySchedule, rounds)
        for var round = rounds - 1, round > 0, round = round - 1 {
            invShiftRows(state)
            invSubBytes(state)
            addRoundKey(state, keySchedule, round)
            invMixColumns(state)
        }
        invShiftRows(state)
        invSubBytes(state)
        addRoundKey(state, keySchedule, 0)
        return toBytes(state)
    }

    fn expandKey(key) {
        var expanded = []
        const var keySize = key.size()
        expanded.setSize(4 * (keySize + 7))
        for var i = 0, i < keySize, i = i + 1 {
            expanded.set(i, key.at(i))
        }
        var temp
        for var i = keySize, i < expanded.size(), i = i + 1 {
            temp = expanded.at(i - 1)
            if i % keySize == 0 {
                temp = subWord(rotWord(temp)) ^^ rcon(i / keySize)
            }
            expanded.set(i, expanded.at(i - keySize) ^^ temp)
        }
        return expanded
    }

    fn subBytes(state) {
        for var i = 0, i < state.size(), i = i + 1 {
            state.set(i, sbox(state.at(i)))
        }
    }

    fn invSubBytes(state) {
        for var i = 0, i < state.size(), i = i + 1 {
            state.set(i, invSbox(state.at(i)))
        }
    }

    fn shiftRows(state) {
        // TODO: Shifts rows of the state array
    }

    fn invShiftRows(state) {
        // TODO: Inverse shifts rows of the state array
    }

    fn mixColumns(state) {
        // TODO: Mix columns of the state array
    }

    fn invMixColumns(state) {
        // TODO: Inverse mix columns of the state array
    }

    fn addRoundKey(state, keySchedule, round) {
        for var i = 0, i < state.size(), i = i + 1 {
            state.set(i, state.at(i) ^^ keySchedule.at(round * 4 + i))
        }
    }
}